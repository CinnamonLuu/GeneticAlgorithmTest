// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel LineIntersection
#pragma kernel CalculateObstacleIntersection
#pragma kernel CalculateObstacleMultiplier
#pragma kernel CalculateFitness
#pragma kernel CalculateDistanceManhattan
#pragma kernel CalculateDistanceEuclidean
#pragma kernel CalculateDistanceChevyshev

struct Line
{
	float2 pointA;
	float2 pointB;
};

struct Obstacle
{
	RWStructuredBuffer<Line> obstacleLines;
};

    /*-------------------------INTERSECTION----------------------------- */

int numMovements;

RWStructuredBuffer<Line> _obstacleBounds;
RWStructuredBuffer<Line> _path;
RWStructuredBuffer<int> _intersects;


    /*-------------------------OBSTACLES----------------------------- */

int numObstacles;

RWStructuredBuffer<Obstacle> _obstacles;
RWStructuredBuffer<int> _numObstacleIntersection;



    /*-------------------------FITNESS----------------------------- */


RWStructuredBuffer<float> _obstacleMultiplier;


RWStructuredBuffer<float> _fitness;

    /*-------------------------DISTANCES----------------------------- */
float2 _targetPoint;

RWStructuredBuffer<float2> _lastAgentPosition;
RWStructuredBuffer<float> _distances;


bool IsPointsOnDifferentSides(float2 obsA, float2 obsB, float2 pathA, float2 pathB)
{
	bool isOnDifferentSides = false;
	
	//The direction of the line
	float2 lineDir = obsB - obsA;

	//The normal to a line is just flipping x and y and making y negative
	float2 lineNormal = float2(-lineDir.y, lineDir.x);
	
	//Now we need to take the dot product between the normal and the points on the other line
	float dot1 = dot(lineNormal, pathA - obsA);
	float dot2 = dot(lineNormal, pathB - obsA);

	//If you multiply them and get a negative value then p3 and p4 are on different sides of the line
	if (dot1 * dot2 < 0)
	{
		isOnDifferentSides = true;
	}

	return isOnDifferentSides;
}

bool AreLineSegmentsIntersectingDotProduct(Line obstacleLine, Line pathLine)
{
	bool isIntersecting = false;

	if (IsPointsOnDifferentSides(obstacleLine.pointA, obstacleLine.pointB, pathLine.pointA, pathLine.pointB)
		&& IsPointsOnDifferentSides(pathLine.pointA, pathLine.pointB, obstacleLine.pointA, obstacleLine.pointB))
	{
		isIntersecting = true;
	}

	return isIntersecting;
}

[numthreads(8, 8, 1)]
void LineIntersection(uint3 id : SV_DispatchThreadID)
{
	if (AreLineSegmentsIntersectingDotProduct(_obstacleBounds[id.x], _path[id.y]))
		_intersects[id.y / numMovements] = 1;
	else
		_intersects[id.y / numMovements] = 0;
	
}

[numthreads(8, 8, 1)]
void CalculateObstacleIntersection()
{
	for (int i = 0; i < numObstacles; i++)
	{
		
	}

}

[numthreads(8, 8, 1)]
void CalculateObstacleMultiplier(uint3 id : SV_DispatchThreadID)
{
		//TODO Wrong Indexes
	_obstacleMultiplier[id.x] = 1 - (0.1 * _numObstacleIntersection[id.y]);

}

[numthreads(8, 8, 1)]
void CalculateFitness(uint3 id : SV_DispatchThreadID)
{
	//TODO Wrong Indexes
	_fitness[id.x / numObstacles] =
					60 / _distances[id.x / numObstacles]
					* (_intersects[id.x] == 1 ? 0.65 : 1)
					* _obstacleMultiplier[id.x];

}

[numthreads(8, 8, 1)]
void CalculateDistanceManhattan(uint3 id : SV_DispatchThreadID)
{
	_distances[id.x] = abs(_lastAgentPosition[id.x].x - _targetPoint.x)
						* abs(_lastAgentPosition[id.x].y - _targetPoint.y);
}

[numthreads(8, 8, 1)]
void CalculateDistanceEuclidean(uint3 id : SV_DispatchThreadID)
{
	_distances[id.x] = distance(_lastAgentPosition[id.x], _targetPoint);
}

[numthreads(8, 8, 1)]
void CalculateDistanceChevyshev(uint3 id : SV_DispatchThreadID)
{
	_distances[id.x] = max(_lastAgentPosition[id.x].x - _targetPoint.x,
							_lastAgentPosition[id.x].y - _targetPoint.y);

}

